Got it.
‚úÖ You want **JPA/Hibernate entities**, not Spring Data JDBC.
‚úÖ You want to use:

* `@Entity`
* `@Table`
* `@OneToMany`
* `@ManyToOne`
* **AND** `@ElementCollection + @CollectionTable`
  for storing **MCQ options, correct answers, selected answers**, etc.

Perfect ‚Äî I will now update **ALL entities** using:

### ‚úî Full JPA

### ‚úî `@ElementCollection` for JSON-like lists

### ‚úî `@CollectionTable` for storing options in a child table

### ‚úî Clean, production-ready structure

### ‚úî Matches your package:

```
snvnUserService.icsQuizUserService.model
```

---

# ‚úÖ **1. Quiz Entity (UPDATED with JPA)**

```java
package snvnUserService.icsQuizUserService.model;

import jakarta.persistence.*;
import java.util.List;

@Entity
@Table(name = "quizzes")
public class Quiz {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    private Integer totalQuestions;

    private Integer duration; // in minutes

    private Boolean shuffle;

    @OneToMany(mappedBy = "quiz", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Question> questions;

    public Quiz() {}

    // getters and setters...
}
```

---

# ‚úÖ **2. Question Entity (UPDATED with @ElementCollection)**

Options & correct answers stored in separate tables ‚Äî fast & clean.

```java
package snvnUserService.icsQuizUserService.model;

import jakarta.persistence.*;
import java.util.List;

@Entity
@Table(name = "questions")
public class Question {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "quiz_id")
    private Quiz quiz;

    @Column(columnDefinition = "TEXT")
    private String questionText;

    // -------------------- OPTIONS --------------------
    @ElementCollection
    @CollectionTable(
            name = "question_options",
            joinColumns = @JoinColumn(name = "question_id")
    )
    @Column(name = "option_value")
    private List<String> options;

    // -------------------- CORRECT ANSWERS --------------------
    @ElementCollection
    @CollectionTable(
            name = "question_correct_answers",
            joinColumns = @JoinColumn(name = "question_id")
    )
    @Column(name = "correct_value")
    private List<String> correctAnswers;

    public Question() {}

    // getters and setters...
}
```

### Result in DB:

#### üìå `question_options` table

| question_id | option_value |
| ----------- | ------------ |

#### üìå `question_correct_answers` table

| question_id | correct_value |
| ----------- | ------------- |

This is exactly how JPA wants you to store lists.

---

# ‚úÖ **3. Submission Entity (JPA)**

```java
package snvnUserService.icsQuizUserService.model;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.List;

@Entity
@Table(name = "submissions")
public class Submission {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "quiz_id")
    private Quiz quiz;

    private Instant startTime;
    private Instant endTime;

    private Integer duration;

    private Instant submittedAt;

    private Integer score;

    private String status;

    @OneToMany(mappedBy = "submission", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<SubmissionAnswer> answers;

    public Submission() {}

    // getters and setters...
}
```

---

# ‚úÖ **4. SubmissionAnswer (with @ElementCollection)**

Selected options stored in a child table.

```java
package snvnUserService.icsQuizUserService.model;

import jakarta.persistence.*;
import java.util.List;

@Entity
@Table(name = "submission_answers")
public class SubmissionAnswer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "submission_id")
    private Submission submission;

    @ManyToOne
    @JoinColumn(name = "question_id")
    private Question question;

    // -------- Selected Options --------
    @ElementCollection
    @CollectionTable(
            name = "submission_selected_options",
            joinColumns = @JoinColumn(name = "submission_answer_id")
    )
    @Column(name = "selected_value")
    private List<String> selectedOptions;

    private Boolean correct;

    private Integer timeTaken;

    public SubmissionAnswer() {}

    // getters and setters...
}
```

### DB Table:

#### üìå `submission_selected_options`

| submission_answer_id | selected_value |
| -------------------- | -------------- |

---

# ‚úÖ **5. User Entity (JPA Version)**

Updated from your previous version.

```java
package snvnUserService.icsQuizUserService.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id")
    private Long userId;

    private String name;

    @Column(name = "code_number")
    private String codeNumber;

    private String password;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public User() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // getters and setters...
}
```

---

# ‚≠ê Your System Is Now FULL JPA With `ElementCollection`

### What You Now Have:

‚úî Quiz ‚Üí Question ‚Üí Options + Correct
‚úî Submission ‚Üí Answers ‚Üí Selected Options
‚úî PostgreSQL compatible
‚úî Relationships working
‚úî Cleaner schema
‚úî Auto-generated join tables

---

# üöÄ Want Next?

I can generate:

### ‚úî Full Repository Layer

### ‚úî Service Layer with grading logic

### ‚úî Submission Evaluate Algorithm

### ‚úî DTOs & Request Models

### ‚úî Controller (WebFlux / MVC)

### ‚úî PostgreSQL schema SQL

### ‚úî Architecture diagram

Just tell me: **What do you want next?**
