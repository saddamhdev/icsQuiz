Great â€” **Dynamic Result Showing** (Real-Time Result Display) is one of the most important parts of an online exam system like ICS Quiz.

If result should update **instantly** as students submit answers, AND scale up to **50,000+ concurrent users**, then you need a **high-performance result processing architecture** inside the Submission Service.

Below is **full production-grade documentation** for Dynamic Result Generation & Real-time Result Streaming.

---

# ğŸ¯ **Goal: Show results dynamically after submission**

Your exam system should support:

### âœ” Instant scoring

### âœ” Live correct/incorrect count

### âœ” Live total marks

### âœ” Updating UI in milliseconds

### âœ” No DB bottleneck

### âœ” Works for 50k+ concurrent users

---

# ğŸ§  **Two Types of Dynamic Result**

### **1) Immediate Scoring (per question submission)**

After each question submitted â†’ server responds with:

* Correct / Incorrect
* Updated score
* Time taken

### **2) Live Result Page (after final submission)**

After finishing the exam â†’ student sees full result instantly:

* Marks
* Correct/Incorrect breakdown
* Time per question
* Detailed analytics

---

# ğŸ— **How Dynamic Result Will Work (Architecture)**

Dynamic Results CANNOT be generated directly from PostgreSQL during peak exam time â€” this will crash the DB.

So we use:

### âœ” Submission Service

### âœ” Redis for Real-time Scoring

### âœ” RabbitMQ for event stream

### âœ” Worker for DB write

### âœ” Result Engine for recalculation

---

# ğŸ§© **Dynamic Result Architecture Flow**

```
                Student Submission
                       â”‚
                       â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Submission API Service â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
             Validate Answer + Fetch Correct Answer
                          â”‚
                          â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Redis Result Engine      â”‚
              â”‚  (Real-time scoring)     â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
           Instant Result â†â”€â”€â”˜ (Correct / Incorrect)
                            â”‚
                            â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Publish to RabbitMQ (stream)    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ Worker Service â†’ PostgreSQL     â”‚
           â”‚   (Batch writes, not realtime) â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ğŸ§  **Dynamic Scoring Logic (Inside Submission Service)**

### âœ“ When a student submits an answer:

1. Get the correct answer from:

   * Redis cache (`exam:<id>:mcq`)

2. Compare:

   ```
   submittedOption == correctOption
   ```

3. If correct:

   ```
   increment score in Redis
   ```

4. Save real-time result in Redis:

```
redis.hset("result:<studentId>:<examId>", "score", 17)
redis.hset("result:<studentId>:<examId>", "correct", 17)
redis.hset("result:<studentId>:<examId>", "wrong", 3)
redis.hset("result:<studentId>:<examId>", "attempted", 20)
```

5. Respond to student immediately:

```
{
  "result": {
     "correct": 17,
     "wrong": 3,
     "score": 17,
     "attempted": 20
  }
}
```

---

# ğŸš€ **Why Redis? (Super Fast Dynamic Results)**

Redis operations take:

```
0.3â€“1 ms
```

So you can compute dynamic results REAL-TIME even under **very high load**.

---

# ğŸ¯ **Dynamic Result Example Response**

### After hitting "Submit" button:

```json
{
  "correct": true,
  "correctAnswer": "B",
  "yourAnswer": "B",
  "updatedScore": 37,
  "totalAttempted": 40,
  "negativeMarking": 0,
  "timeTaken": 4.2
}
```

---

# ğŸ”¥ **Live Result (Before Student Finishes Exam)**

Student hits:

```
/result/live
```

Server returns Redis values instantly:

```json
{
  "correct": 73,
  "wrong": 27,
  "score": 73,
  "attempted": 100
}
```

Latency:

```
< 5 ms
```

---

# ğŸŸ¦ **How Final Result is Saved to DB?**

### Worker â†’ RabbitMQ â†’ PostgreSQL

After exam finishes:

1. Submission API publishes final result event:

```
event: "exam.completed"
studentId: ...
totalScore: ...
```

2. Worker stores to PostgreSQL:

```
exam_result table:
student_id
exam_id
score
correct
wrong
time_taken
submitted_at
```

---

# ğŸ§¨ **IMPORTANT: Donâ€™t Calculate Final Score from DB**

Because:

* DB has raw answers
* Scores must be calculated from Redis real-time cache
* Redis is the source-of-truth for result accuracy
* Final result stored AFTER exam

If you calculate from DB during peak:

âŒ DB reads = slow
âŒ 50k students = DB overload
âŒ GC pressure on backend
âŒ Exam failure risk

Redis â†’ always fast and stable.

---

# ğŸ“¦ **Dynamic Result Data Model (Redis)**

Per student:

```
result:<studentId>:<examId>
   score = 37
   correct = 37
   wrong = 3
   attempted = 40
   timestamps = [...]
```

Per question:

```
answer:<studentId>:<questionId>
```

Correct answers:

```
correct:<questionId> = "B"
```

---

# ğŸ”¥ **Dynamic Result Scaling (50k concurrent)**

Redis cluster memory requirement:

```
100,000 students Ã— ~100 KB = 10 MB
```

Very small.

Throughput capacity:

```
> 100,000 ops per second (AWS Redis)
```

This means:

* All 50k students can submit answers
* Redis updates results instantly
* No slowdown

---

# ğŸ§± **Dynamic Result UI Updates (Frontend)**

Two options:

## **Option A â€” Pull API**

Frontend polls every 2â€“5 seconds:

```
GET /result/live
```

Pros: simple
Cons: more HTTP requests

## **Option B â€” WebSocket / SSE**

Server pushes updates:

```
scoreUpdate = 37
```

Pros: real-time
Cons: more complex backend

For exam system:
**Option A is better and safer.**

---

# ğŸ“ **Dynamic Result API List**

| API                 | Description                                  |
| ------------------- | -------------------------------------------- |
| `POST /exam/submit` | Submit single question & get real-time score |
| `GET /result/live`  | Get current score                            |
| `POST /exam/finish` | Store final result                           |
| `GET /result/final` | After worker writes to DB                    |

---

# ğŸ“Š **Overall Dynamic Result Architecture Summary**

| Layer          | Works On               | Purpose                    |
| -------------- | ---------------------- | -------------------------- |
| Submission API | Spring Boot            | Validate & score instantly |
| Redis          | Real-time scoring      | Millisecond scoring        |
| RabbitMQ       | Stream events          | Async DB writes            |
| Worker Service | Batch writes           | Efficient data durability  |
| PostgreSQL     | Permanent result store | Reporting + analytics      |

---

# ğŸŸ© **Final: Ready-to-use Dynamic Submission + Result Diagram**

```
Student
  â†“ POST /exam/submit
Submission API
  â†“ (score instantly)
Redis (result:<student>)
  â†“ (publish)
RabbitMQ Queue
  â†“ (batch)
Worker Pods
  â†“ bulk insert
PostgreSQL (exam_result)
  â†“
Student sees dynamic score
```

---

# ğŸ Do you want the diagrams?

I can give:

### ğŸ“Œ Dynamic Result Architecture (PNG/SVG)

### ğŸ“Œ Redis data model diagram

### ğŸ“Œ Worker pipeline diagram

### ğŸ“Œ Full submission + scoring + analytics diagram

### ğŸ“Œ draw.io or PPT version

Just tell me:

ğŸ‘‰ **â€œGive Dynamic Result Diagram (PNG)â€**
or
ğŸ‘‰ **â€œGive draw.io file for result systemâ€**
